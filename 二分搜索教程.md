![顺峰山下](http://img.blog.csdn.net/20171019214104434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuY29tMjAxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 大家好啊！好久不见，我怕是两个多月没写推文了吧！不过没事，我回来啦，ヾ(๑╹◡╹)ﾉ"
 一回来发现自己公众号的关注人数上升到了18人，很震惊，自己什么都没写。然后自己想了一想，哦，原来是自己前段时间加入了几个程序员的群，在一次聊天中我把自己的公众号推了出去。哈哈，想必他们（你们）都是已经出来工作的了，相对而言我肯定是个渣渣啦(T＿T) 不过也要感谢大家的关注，大家对我的支持将是我不断分享心得的动力，谢谢！
 ![这里写图片描述](http://img.blog.csdn.net/20171019220418772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuY29tMjAxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 自八月中旬以来就没写过了，主要自己的一些坏习惯吧，额，其实也不能叫做坏习惯，主要是自己执行力低and找不到这个工作生活规律。。。
 最近打算学算法。。（算法重要的感想）
 好，开始今天的推文吧。这篇推文将介绍一种查找算法，二分查找（Binary search），这是算法一个非常重要的基础知识。


> **Binary search** is the most popular Search algorithm.It is efficient and also one of the most commonly used techniques that is used to solve problems.

 介绍完这一种算法之后了，我会写一个暴力的方法（就是直接从前往后找）来对比一下，性能之间的差异到底如何。

## 相关参考

### 网站


 - https://www.hackerearth.com/zh/practice/algorithms/searching/binary-search/tutorial/
 - ["二分搜索算法-维基百科"](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95 )

### 书籍
《算法（第四版）》Robert Sedgewick 著 P28 - P30

### 课程
 http://coding.imooc.com/class/71.html

## 开始之前
 在正式开始之前，我们需要设计一个东西（一个类），我们使用它来方便我们对算法进行测试。这个类实现一个简单的功能：

 1. 自动生成，给定数目（n）的范围是在[a,b] (注意是闭区间) 的随机数

 写成一个API表大概是这样↓↓↓↓↓↓

![SearchTestHelper API](http://img.blog.csdn.net/20171020194722788?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuY29tMjAxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 好我们根据这个API实现这个功能

```
//这个类用来生成，测试所需的随机数
public class SearchTestHelper {
    public static Integer[] generateRandomArray(int n, int rangeL, int rangeR){
        assert rangeL <= rangeR; //arrest 代表断言，简单理解就是，后面的表达式为false，程序就会中断报错

        Integer[] arr = new Integer[n];

        for (int i = 0; i < n; i++) {
            arr[i] = new Integer((int)(Math.random()*(rangeR+1-rangeL)+rangeL));
        }

        return arr;
    }
}
```

 嘻嘻，代码能看懂吧，不解释啦。哦，为什么要用Integer不用int呢，你们先猜猜（思考思考）到了后面就知道了！！！
![](http://img.blog.csdn.net/20171020195355245?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuY29tMjAxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 什么是二分查找

> 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）是一种在有序数组中查找某一特定元素的搜索算法。From：维基百科

 通过维基百科上的定义，大家应该马上就能够明白什么叫做二分查找了，就是在一个有序数组中找到某一个元素的搜索算法。
 这里有一个非常重要的条件就是：**有序的数组**，**有序的数组**，**有序的数组**
 The important thing must  be spoken three times！！！❥(ゝω・✿ฺ)
 所以我们在使用这一种算法的时候，传入要被查找的数组，它一定是要**有序的**，否则，算法将会无效！！！

## 二分查找的原理
 查找的原理是什么呢？这有点像我们查英文字典，我们知道，字典单词是有序排序的。我们想找到open这个单词的意思，我们就大概估计下o的位置，如果我们翻开了r开头的单词页，我们就知道open一定在前面，于是就向前翻翻到了om开头的词，于是我们就知道，open一定在后面。。。通过这样的方法，我们最终就能找到open这个单词。二分查找就类似于这个方法，只是不像我们翻页时估计一下在哪再翻，而是从中间开始翻。
 我们来看个图（来自：慕课网刘宇波老师的算法课PPT，链接在参考课程一栏）
![这里写图片描述](http://img.blog.csdn.net/20171020220737382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuY29tMjAxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 我们知道我们的数组是有序的了，那么，我们看上图，v代表数组中间的元素，它的索引是mid。
 由于数组是有序的，所以v左边的元素都是小于v的，v右边的元素都是大于v的。那么，假设我们想查找key，我们就将key与v进行比较，如果：
 key小于v，那么我们就在 ＜v 的部分继续查找
 key大于v，那么我们就在 ＞v 的部分继续查找
 key等于v，那很好，我们已经找到了我们要查找的元素。
 如此不断的把搜索范围缩小一半，直到找到该元素为止。
 以上就是二分查找的原理！！！

 ![这里写图片描述](http://img.blog.csdn.net/20171020225057533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuY29tMjAxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 这张图就展现了，整个二分查找的过程（画了我好久...）

## 二分查找的实现

### 用例测试

```
    public static void main(String[] args) {
        Integer[] keys = new Integer[]{0,2,4,6,8,10,12,14};
        Integer[] a = new Integer[]{1,2,3,4,5,6,7,8,9,10};
        int result;
        for (int key : keys) {
            if(rank(key, a) != -1){
                System.out.printf("找到了%d\n",key);
            }
            else {
                System.out.printf("没找到%d\n",key);
            }
        }
    }
```

 输出结果：

没找到0
找到了2
找到了4
找到了6
找到了8
找到了10
没找到12
没找到14

 这样，看来程序（BinarySearch）是能够正常工作的。好下面我们来看看具体二分查找是如何实现的。
### 具体实现

```
// 二分查找
// 二分查找法，在有序数组arr中查找key
// 如果找到key，返回相应的索引
// 如果没有找到key，返回-1

public class BinarySearch {
    public static int rank(Comparable key, Comparable[] arr){
        // 在[left,right]之间查找key
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if        (key.compareTo(arr[mid])<0) {
                // 在[left,mid-1]之间查找key
                right = mid - 1;
            }
            else if (key.compareTo(arr[mid])>0) {
                // 在[mid+1,right]之间查找key
                left = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
}
```